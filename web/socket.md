### Содержание
- [Содержание](#содержание)
- [Background](#background)
- [Socket API Overview](#socket-api-overview)
- [TCP Sockets](#tcp-sockets)
- [Слишком много опасностей запроса между различными источниками](#слишком-много-опасностей-запроса-между-различными-источниками)
- [Политика одинакового источника](#политика-одинакового-источника)
- [Врываемся в CORS](#врываемся-в-cors)
- [Запись из разных источников](#запись-из-разных-источников)
- [Предварительные запросы](#предварительные-запросы)
- [Считывание из разных источников](#считывание-из-разных-источников)
- [Тонкая настройка CORS](#тонкая-настройка-cors)
- [Несколько правильных решений](#несколько-правильных-решений)
- [Свободный доступ для всех](#свободный-доступ-для-всех)
- [Всё в семью](#всё-в-семью)
- [Null источник](#null-источник)
- [Пропускай куки, если возможно](#пропускай-куки-если-возможно)
- [Примеры управления корсами в питонячьих фреймворках](#примеры-управления-корсами-в-питонячьих-фреймворках)

Сокеты и API сокетов используются для отправки сообщений по сети. Они обеспечивают форму межпроцессного взаимодействия (IPC). Сеть может быть логической локальной сетью для компьютера или сетью, которая физически подключена к внешней сети с собственными подключениями к другим сетям. Очевидным примером является Интернет, к которому вы подключаетесь через своего провайдера.

В этом уроке вы создадите:

Простой сокет-сервер и клиент
Улучшенная версия, которая одновременно обрабатывает несколько подключений.
Серверно-клиентское приложение, функционирующее как полноценное приложение для сокетов, с собственным пользовательским заголовком и содержимым.
К концу этого руководства вы поймете, как использовать основные функции и методы модуля сокетов Python для написания собственных клиент-серверных приложений. Вы узнаете, как использовать пользовательский класс для отправки сообщений и данных между конечными точками, которые вы можете использовать в своих собственных приложениях.

Для примеров в этом руководстве требуется Python 3.6 или более поздней версии, и они были протестированы с использованием Python 3.10. Чтобы получить максимальную отдачу от этого руководства, лучше загрузить исходный код и иметь его под рукой для справки при чтении:
Сеть и сокеты - большие темы. О них написаны тома. Если вы новичок в сокетах или сетях, это совершенно нормально, если вы чувствуете себя перегруженным всеми терминами и частями.

Однако не отчаивайтесь. Этот урок для вас! Как и во всем, что связано с Python, вы можете учиться понемногу за раз. Добавьте эту статью в закладки и вернитесь, когда будете готовы к следующему разделу.

### Background

Сокеты имеют долгую историю. Их использование началось с ARPANET в 1971 году, а позже стало API в операционной системе Berkeley Software Distribution (BSD), выпущенной в 1983 году, под названием сокеты Berkeley.

Когда в 1990-х годах Интернет стал популярным благодаря Всемирной паутине, то же самое произошло и с сетевым программированием. Веб-серверы и браузеры были не единственными приложениями, использующими преимущества новых подключенных сетей и сокетов. Широкое распространение получили клиент-серверные приложения всех типов и размеров.

Сегодня, хотя базовые протоколы, используемые API сокетов, развивались с годами и разрабатывались новые, низкоуровневый API остался прежним.

Наиболее распространенным типом сокет-приложений являются клиент-серверные приложения, где одна сторона выступает в роли сервера и ожидает подключения от клиентов. Это тип приложения, которое вы будете создавать в этом руководстве. В частности, вы сосредоточитесь на API сокетов для Интернет-сокетов, иногда называемых сокетами Беркли или BSD. Существуют также сокеты домена Unix, которые можно использовать только для связи между процессами на одном хосте.

### Socket API Overview

Модуль сокетов Python предоставляет интерфейс к API сокетов Беркли. Это модуль, который вы будете использовать в этом руководстве.

Основные функции и методы API сокетов в этом модуле:

socket()
.bind()
.listen()
.accept()
.connect()
.connect_ex()
.send()
.recv()
.close()
Python предоставляет удобный и согласованный API, который напрямую сопоставляется с системными вызовами, их аналогами C. В следующем разделе вы узнаете, как они используются вместе.

В стандартной библиотеке Python также есть классы, упрощающие использование этих низкоуровневых функций сокетов. Хотя это не рассматривается в этом руководстве, вы можете проверить модуль socketserver, инфраструктуру для сетевых серверов. Также доступно множество модулей, которые реализуют интернет-протоколы более высокого уровня, такие как HTTP и SMTP. Обзор см. в разделе Интернет-протоколы и поддержка.

### TCP Sockets

Вы собираетесь создать объект сокета, используя socket.socket(), указав тип сокета как socket.SOCK_STREAM. При этом по умолчанию используется протокол управления передачей (TCP). Это хорошее значение по умолчанию и, вероятно, то, что вы хотите.

Почему вы должны использовать TCP? Протокол управления передачей (TCP):

Является надежным: пакеты, отброшенные в сеть, обнаруживаются и повторно передаются отправителем.
Имеет упорядоченную доставку данных: данные считываются вашим приложением в том порядке, в котором они были записаны отправителем.
Напротив, сокеты протокола пользовательских дейтаграмм (UDP), созданные с помощью socket.SOCK_DGRAM, ненадежны, и данные, считанные получателем, могут быть не в порядке из-за записи отправителя.

Почему это важно? Сети — это система доставки с максимальной эффективностью. Нет никакой гарантии, что ваши данные достигнут места назначения или что вы получите то, что вам было отправлено.

Сетевые устройства, такие как маршрутизаторы и коммутаторы, имеют ограниченную доступную полосу пропускания и имеют свои системные ограничения. У них есть процессоры, память, шины и буферы интерфейсных пакетов, как и у ваших клиентов и серверов. TCP избавляет вас от беспокойства о потере пакетов, получении данных не по порядку и других ловушках, которые неизбежно случаются при общении по сети.

Чтобы лучше понять это, ознакомьтесь с последовательностью вызовов API сокетов и потоком данных для TCP:

![image](socket_img/socket_1.png)

Левая колонка представляет сервер. Справа клиент.

Начиная с верхнего левого столбца, обратите внимание на вызовы API, которые сервер делает для настройки «слушающего» сокета:

socket()
.bind()
.listen()
.accept()

Прослушивающий сокет делает именно то, что следует из его названия. Он прослушивает подключения от клиентов. Когда клиент подключается, сервер вызывает .accept(), чтобы принять или завершить соединение.

Клиент вызывает .connect(), чтобы установить соединение с сервером и инициировать трехстороннее рукопожатие. Этап рукопожатия важен, потому что он гарантирует, что каждая сторона соединения доступна в сети, другими словами, что клиент может связаться с сервером и наоборот. Может случиться так, что только один хост, клиент или сервер могут связаться с другим.

Посередине находится секция приема-передачи, где происходит обмен данными между клиентом и сервером с использованием вызовов .send() и .recv().

Внизу клиент и сервер закрывают свои соответствующие сокеты.

### Echo Client and Server

Теперь, когда вы получили представление об API сокетов и о том, как взаимодействуют клиент и сервер, вы готовы создать свой первый клиент и сервер. Вы начнете с простой реализации. Сервер просто отобразит все, что он получит, обратно клиенту.

# Echo Server
Вот сервер:

```cython
# echo-server.py

import socket

HOST = "127.0.0.1"  # Standard loopback interface address (localhost)
PORT = 65432  # Port to listen on (non-privileged ports are > 1023)

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    conn, addr = s.accept()
    with conn:
        print(f"Connected by {addr}")
        while True:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(data)
```

Итак, что именно происходит в вызове API?

socket.socket() создает объект сокета, который поддерживает тип диспетчера контекста, поэтому вы можете использовать его в операторе with. Нет необходимости вызывать s.close():

```cython
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    pass  # Use the socket object without calling s.close().
```

Аргументы, передаваемые в socket(), представляют собой константы, используемые для указания семейства адресов и типа сокета. AF_INET — это семейство интернет-адресов для IPv4. SOCK_STREAM — это тип сокета для TCP, протокола, который будет использоваться для передачи сообщений в сети.

Метод .bind() используется для связывания сокета с определенным сетевым интерфейсом и номером порта:

```cython
# echo-server.py

# ...

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    # ...
```

Значения, передаваемые в .bind(), зависят от семейства адресов сокета. В этом примере вы используете socket.AF_INET (IPv4). Поэтому он ожидает два кортежа: (хост, порт).

host может быть именем хоста, IP-адресом или пустой строкой. Если используется IP-адрес, хост должен быть строкой адреса в формате IPv4. IP-адрес 127.0.0.1 — это стандартный адрес IPv4 для интерфейса обратной связи, поэтому только процессы на хосте смогут подключиться к серверу. Если вы передадите пустую строку, сервер будет принимать соединения на всех доступных интерфейсах IPv4.

port представляет номер порта TCP для приема соединений от клиентов. Это должно быть целое число от 1 до 65535, так как 0 зарезервирован. В некоторых системах могут потребоваться привилегии суперпользователя, если номер порта меньше 1024.

Вот примечание об использовании имен хостов с .bind():
«Если вы используете имя хоста в части хоста адреса сокета IPv4/v6, программа может демонстрировать недетерминированное поведение, поскольку Python использует первый адрес, возвращенный из разрешения DNS. Адрес сокета будет по-разному преобразован в фактический адрес IPv4/v6, в зависимости от результатов разрешения DNS и/или конфигурации хоста. Для детерминированного поведения используйте числовой адрес в части хоста».

Вы узнаете больше об этом позже, в разделе Использование имен хостов. А пока просто поймите, что при использовании имени хоста вы можете увидеть разные результаты в зависимости от того, что возвращается в результате процесса разрешения имени. Эти результаты могут быть какими угодно. При первом запуске приложения вы можете получить адрес 10.1.2.3. В следующий раз вы получите другой адрес, 192.168.0.1. В третий раз вы можете получить 172.16.7.8 и так далее.

В примере с сервером .listen() позволяет серверу принимать соединения. Это делает сервер «слушающим» сокетом:

```cython
# echo-server.py

# ...

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    conn, addr = s.accept()
    # ...
```

Метод .listen() имеет параметр невыполненной работы. Он указывает количество непринятых подключений, которые система разрешает, прежде чем отклонять новые подключения. Начиная с Python 3.5, это необязательно. Если не указано, выбирается значение невыполненной работы по умолчанию.

Если ваш сервер одновременно получает много запросов на подключение, может помочь увеличение значения невыполненной работы путем установки максимальной длины очереди для ожидающих подключений. Максимальное значение зависит от системы. Например, в Linux см. /proc/sys/net/core/somaxconn.

Метод .accept() блокирует выполнение и ожидает входящего соединения. Когда клиент подключается, он возвращает новый объект сокета, представляющий соединение, и кортеж, содержащий адрес клиента. Кортеж будет содержать (хост, порт) для соединений IPv4 или (хост, порт, информацию о потоке, область видимости) для IPv6. Дополнительные сведения о значениях кортежа см. в разделе «Семейства адресов сокетов» в справочном разделе.

Одна вещь, которую необходимо понять, это то, что теперь у вас есть новый объект сокета из .accept(). Это важно, потому что это сокет, который вы будете использовать для связи с клиентом. Он отличается от прослушивающего сокета, который сервер использует для приема новых подключений:

```cython
# echo-server.py

# ...

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    conn, addr = s.accept()
    with conn:
        print(f"Connected by {addr}")
        while True:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(data)
```

После того, как .accept() предоставляет объект клиентского сокета conn, бесконечный цикл while используется для перебора блокирующих вызовов conn.recv(). Это считывает любые данные, которые отправляет клиент, и возвращает их обратно, используя conn.sendall().

Если conn.recv() возвращает объект пустых байтов, b'', это сигнализирует о том, что клиент закрыл соединение и цикл завершен. Оператор with используется с conn для автоматического закрытия сокета в конце блока.

# Echo Client

Посмотрим на клиент:

```cython
# echo-client.py

import socket

HOST = "127.0.0.1"  # The server's hostname or IP address
PORT = 65432  # The port used by the server

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    s.sendall(b"Hello, world")
    data = s.recv(1024)

print(f"Received {data!r}")
```

По сравнению с сервером клиент довольно прост. Он создает объект сокета, использует .connect() для подключения к серверу и вызывает s.sendall() для отправки своего сообщения. Наконец, он вызывает s.recv(), чтобы прочитать ответ сервера, а затем распечатать его.

# Running the Echo Client and Server

В этом разделе вы запустите клиент и сервер, чтобы увидеть, как они себя ведут, и проследите, что происходит.
Откройте терминал или командную строку, перейдите в каталог, содержащий ваши сценарии, убедитесь, что у вас установлен Python 3.6 или более поздней версии и указан путь, затем запустите сервер:
```pycon
python echo-server.py
```
Ваш терминал будет зависать. Это потому, что сервер заблокирован или приостановлен на .accept():

```cython
# echo-server.py

# ...

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    conn, addr = s.accept()
    with conn:
        print(f"Connected by {addr}")
        while True:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(data)
```

Ожидает подключения клиента. Теперь откройте другое окно терминала или командную строку и запустите клиент:

```pycon
python echo-client.py 
Received b'Hello, world'
```

В окне сервера вы должны заметить что-то вроде этого:

```pycon
python echo-server.py 
Connected by ('127.0.0.1', 64623)
```

В приведенном выше выводе сервер напечатал кортеж addr, возвращенный из s.accept(). Это IP-адрес клиента и номер TCP-порта. Номер порта 64623, скорее всего, будет другим, когда вы запустите его на своем компьютере.

# Viewing Socket State

Чтобы увидеть текущее состояние сокетов на вашем хосте, используйте netstat. Он доступен по умолчанию в macOS, Linux и Windows.

Вот вывод netstat из macOS после запуска сервера:

```pycon
$ netstat -an
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4       0      0  127.0.0.1.65432        *.*                    LISTEN
```

Обратите внимание, что локальный адрес — 127.0.0.1.65432. Если бы echo-server.py использовал HOST = "" вместо HOST = "127.0.0.1", netstat показал бы это:
```pycon
netstat -an
Active Internet connections (including servers)
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4       0      0  *.65432                *.*                    LISTEN
```

Локальный адрес *.65432 означает, что все доступные хост-интерфейсы, поддерживающие семейство адресов, будут использоваться для приема входящих подключений. В этом примере в вызове socket() использовался socket.AF_INET (IPv4). Вы можете увидеть это в столбце Proto: tcp4.

Приведенный выше вывод обрезан, чтобы отображать только эхо-сервер. Скорее всего, вы увидите гораздо больше вывода, в зависимости от системы, в которой вы его используете. Обратите внимание на столбцы Proto, Local Address и (state). В последнем приведенном выше примере netstat показывает, что эхо-сервер использует TCP-сокет IPv4 (tcp4) на порту 65432 на всех интерфейсах (*.65432) и находится в состоянии прослушивания (LISTEN).

Другой способ получить доступ к этому наряду с дополнительной полезной информацией — использовать lsof (список открытых файлов). Он доступен по умолчанию в macOS и может быть установлен в Linux с помощью диспетчера пакетов, если он еще не установлен:
```pycon
lsof -i -n
COMMAND     PID   USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
Python    67982 nathan    3u  IPv4 0xecf272      0t0  TCP *:65432 (LISTEN)
```

lsof предоставляет вам КОМАНДУ, PID (идентификатор процесса) и ПОЛЬЗОВАТЕЛЯ (идентификатор пользователя) открытых интернет-сокетов при использовании с параметром -i. Выше показан процесс эхо-сервера.

netstat и lsof имеют множество доступных опций и различаются в зависимости от ОС, на которой вы их используете. Проверьте справочную страницу или документацию для обоих. С ними определенно стоит провести немного времени и познакомиться. Вы будете вознаграждены. В macOS и Linux используйте man netstat и man lsof. Для Windows используйте netstat /?.

Вот распространенная ошибка, с которой вы столкнетесь при попытке подключения к порту без прослушивающего сокета:
```pycon
python echo-client.py 
Traceback (most recent call last):
  File "./echo-client.py", line 9, in <module>
    s.connect((HOST, PORT))
ConnectionRefusedError: [Errno 61] Connection refused
```

Либо указан неверный номер порта, либо сервер не запущен. Или, может быть, на пути есть брандмауэр, который блокирует соединение, о котором можно легко забыть. Вы также можете увидеть ошибку Время ожидания подключения истекло. Добавьте правило брандмауэра, позволяющее клиенту подключаться к TCP-порту!

В справочном разделе есть список распространенных ошибок.

### Communication Breakdown

Теперь мы подробнее рассмотрим, как клиент и сервер взаимодействуют друг с другом:

![image](socket_img/socket_2.png)

При использовании loopback-интерфейса (IPv4-адрес 127.0.0.1 или IPv6-адрес ::1) данные никогда не покидают хост и не достигают внешней сети. На приведенной выше диаграмме петлевой интерфейс находится внутри хоста. Это отражает внутреннюю природу интерфейса обратной связи и показывает, что соединения и данные, которые проходят через него, являются локальными для хоста. Вот почему вы также услышите петлевой интерфейс и IP-адрес 127.0.0.1 или ::1, называемый «localhost».

Приложения используют петлевой интерфейс для связи с другими процессами, работающими на хосте, а также для обеспечения безопасности и изоляции от внешней сети. Поскольку он является внутренним и доступен только внутри хоста, он не подвергается воздействию.

Вы можете увидеть это в действии, если у вас есть сервер приложений, который использует свою собственную базу данных. Если это не база данных, используемая другими серверами, возможно, она настроена на прослушивание подключений только через петлевой интерфейс. Если это так, другие хосты в сети не смогут к нему подключиться.

Когда вы используете в своих приложениях IP-адрес, отличный от 127.0.0.1 или ::1, он, вероятно, привязан к интерфейсу Ethernet, подключенному к внешней сети. Это ваш шлюз к другим хостам за пределами вашего королевства «localhost»:

![image](socket_img/socket_3.png)

Будьте осторожны там. Это неприятный, жестокий мир. Обязательно прочитайте раздел «Использование имен хостов», прежде чем выходить из безопасных границ «localhost». Существует примечание о безопасности, которое применяется, даже если вы не используете имена хостов, а используете только IP-адреса.

### Handling Multiple Connections

Эхо-сервер определенно имеет свои ограничения. Самый большой из них заключается в том, что он обслуживает только одного клиента, а затем закрывается. У эхо-клиента тоже есть это ограничение, но есть еще одна проблема. Когда клиент использует s.recv(), возможно, он вернет только один байт, b'H' из b'Hello, world':

```cython
# echo-client.py

# ...

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    s.sendall(b"Hello, world")
    data = s.recv(1024)

print(f"Received {data!r}")
```

Аргумент bufsize 1024, использованный выше, представляет собой максимальный объем данных, которые должны быть получены за один раз. Это не означает, что .recv() вернет 1024 байта.

Так же ведет себя и метод .send(). Он возвращает количество отправленных байтов, которое может быть меньше размера переданных данных. Вы несете ответственность за проверку этого и вызов .send() столько раз, сколько необходимо для отправки всех данных:

«Приложения несут ответственность за проверку того, что все данные были отправлены; если была передана только часть данных, приложению необходимо попытаться доставить оставшиеся данные». (Источник)

В приведенном выше примере вы избежали необходимости делать это, используя .sendall():

«В отличие от send(), этот метод продолжает отправлять данные из байтов до тех пор, пока либо все данные не будут отправлены, либо не произойдет ошибка. В случае успеха ничего не возвращается». (Источник)

На данный момент у вас есть две проблемы:

Как вы обрабатываете несколько подключений одновременно?
Вам нужно вызывать .send() и .recv() до тех пор, пока все данные не будут отправлены или получены.
Что ты можешь сделать? Существует множество подходов к параллелизму. Популярным подходом является использование асинхронного ввода-вывода. asyncio был введен в стандартную библиотеку Python 3.4. Традиционный выбор — использование нитей.

Проблема с параллелизмом в том, что его трудно сделать правильно. Есть много тонкостей, которые нужно учитывать и остерегаться. Все, что требуется, это чтобы один из них проявил себя, и ваше приложение может внезапно дать сбой не очень тонким образом.

Это не предназначено для того, чтобы отпугнуть вас от изучения и использования параллельного программирования. Если ваше приложение нуждается в масштабировании, это необходимо, если вы хотите использовать более одного процессора или одного ядра. Однако в этом уроке вы будете использовать нечто более традиционное, чем потоки, и более простое для понимания. Вы собираетесь использовать дедушку системных вызовов: .select().

Метод .select() позволяет вам проверять завершение ввода-вывода более чем на одном сокете. Таким образом, вы можете вызвать .select(), чтобы увидеть, какие сокеты имеют ввод-вывод, готовый для чтения и/или записи. Но это Python, так что есть еще кое-что. Вы собираетесь использовать модуль selectors в стандартной библиотеке, чтобы использовать наиболее эффективную реализацию, независимо от операционной системы, в которой вы работаете:

«Этот модуль обеспечивает высокоуровневое и эффективное мультиплексирование ввода-вывода, построенное на примитивах модуля select. Пользователям рекомендуется использовать этот модуль вместо этого, если они не хотят точного контроля над используемыми примитивами уровня ОС». (Источник)

Тем не менее, используя .select(), вы не можете работать одновременно. Тем не менее, в зависимости от вашей рабочей нагрузки, этот подход может быть достаточно быстрым. Это зависит от того, что должно делать ваше приложение, когда оно обслуживает запрос, и от количества клиентов, которых оно должно поддерживать.

asyncio использует однопоточную совместную многозадачность и цикл обработки событий для управления задачами. С .select() вы будете писать свою собственную версию цикла событий, хотя и более простую и синхронную. При использовании нескольких потоков, даже если у вас есть параллелизм, в настоящее время вам необходимо использовать GIL (глобальную блокировку интерпретатора) с CPython и PyPy. Это эффективно ограничивает объем работы, которую вы можете выполнять параллельно.

Все это говорит о том, что использование .select() может быть отличным выбором. Не думайте, что вам нужно использовать asyncio, потоки или новейшую асинхронную библиотеку. Как правило, в сетевом приложении ваше приложение в любом случае связано с вводом-выводом: оно может ожидать в локальной сети, конечных точек на другой стороне сети, записи на диск и так далее.

Если вы получаете запросы от клиентов, которые инициируют работу, связанную с процессором, посмотрите на модуль concurrent.futures. Он содержит класс ProcessPoolExecutor, который использует пул процессов для асинхронного выполнения вызовов.

Если вы используете несколько процессов, операционная система может запланировать параллельный запуск вашего кода Python на нескольких процессорах или ядрах без GIL. Для идей и вдохновения см. доклад PyCon John Reese — Thinking Outside the GIL with AsyncIO and Multiprocessing — PyCon 2018.

В следующем разделе вы рассмотрите примеры сервера и клиента, решающих эти проблемы. Они используют .select() для одновременной обработки нескольких подключений и вызывают .send() и .recv() столько раз, сколько необходимо.

### Multi-Connection Client and Server
В следующих двух разделах вы создадите сервер и клиент, которые обрабатывают несколько соединений, используя объект селектора, созданный из модуля селекторов.

# Multi-Connection Server
Во-первых, обратите внимание на сервер с несколькими подключениями. Первая часть устанавливает прослушивающий сокет:

```cython
# multiconn-server.py

import sys
import socket
import selectors
import types

sel = selectors.DefaultSelector()

# ...

host, port = sys.argv[1], int(sys.argv[2])
lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
lsock.bind((host, port))
lsock.listen()
print(f"Listening on {(host, port)}")
lsock.setblocking(False)
sel.register(lsock, selectors.EVENT_READ, data=None)
```

Самая большая разница между этим сервером и эхо-сервером заключается в вызове lsock.setblocking(False) для настройки сокета в неблокирующем режиме. Вызовы, сделанные на этот сокет, больше не будут блокироваться. Когда он используется с sel.select(), как вы увидите ниже, вы можете ждать событий в одном или нескольких сокетах, а затем читать и записывать данные, когда они будут готовы.

sel.register() регистрирует сокет для мониторинга с помощью sel.select() для событий, которые вас интересуют. Для прослушивающего сокета вам нужны события чтения: selectors.EVENT_READ.

Чтобы хранить любые произвольные данные вместе с сокетом, вы будете использовать data. Он возвращается, когда возвращается .select(). Вы будете использовать данные для отслеживания того, что было отправлено и получено через сокет.

Далее идет цикл событий:

```cython
# multiconn-server.py

# ...

try:
    while True:
        events = sel.select(timeout=None)
        for key, mask in events:
            if key.data is None:
                accept_wrapper(key.fileobj)
            else:
                service_connection(key, mask)
except KeyboardInterrupt:
    print("Caught keyboard interrupt, exiting")
finally:
    sel.close()
```

sel.select(timeout=None) блокируется до тех пор, пока сокеты не будут готовы к вводу-выводу. Он возвращает список кортежей, по одному для каждого сокета. Каждый кортеж содержит ключ и маску. Ключ представляет собой именованный кортеж SelectorKey, который содержит атрибут fileobj. key.fileobj — объект сокета, а mask — маска событий готовых операций.

Если key.data имеет значение None, то вы знаете, что это от прослушивающего сокета, и вам нужно принять соединение. Вы вызовете свою собственную функцию accept_wrapper(), чтобы получить новый объект сокета и зарегистрировать его в селекторе. Вы увидите это через мгновение.

Если key.data не None, то вы знаете, что это клиентский сокет, который уже был принят, и вам нужно его обслужить. Затем вызывается service_connection() с ключом и маской в качестве аргументов, и это все, что вам нужно для работы с сокетом.

Вот что делает ваша функция accept_wrapper():

```cython
# multiconn-server.py

# ...

def accept_wrapper(sock):
    conn, addr = sock.accept()  # Should be ready to read
    print(f"Accepted connection from {addr}")
    conn.setblocking(False)
    data = types.SimpleNamespace(addr=addr, inb=b"", outb=b"")
    events = selectors.EVENT_READ | selectors.EVENT_WRITE
    sel.register(conn, events, data=data)

# ...
```

Поскольку прослушивающий сокет был зарегистрирован для селекторов событий.EVENT_READ, он должен быть готов к чтению. Вы вызываете sock.accept(), а затем вызываете conn.setblocking(False), чтобы перевести сокет в неблокирующий режим.

Помните, что это основная цель этой версии сервера, потому что вы не хотите, чтобы он блокировался. Если он блокируется, то весь сервер останавливается, пока он не вернется. Это означает, что другие сокеты остаются в ожидании, даже если сервер активно не работает. Это ужасное состояние «зависания», в котором вы не хотите, чтобы ваш сервер находился.

Затем вы создаете объект для хранения данных, которые вы хотите включить вместе с сокетом, используя SimpleNamespace. Поскольку вы хотите знать, когда клиентское соединение готово для чтения и записи, оба этих события устанавливаются с помощью побитового оператора ИЛИ:

```cython
# multiconn-server.py

# ...

def accept_wrapper(sock):
    conn, addr = sock.accept()  # Should be ready to read
    print(f"Accepted connection from {addr}")
    conn.setblocking(False)
    data = types.SimpleNamespace(addr=addr, inb=b"", outb=b"")
    events = selectors.EVENT_READ | selectors.EVENT_WRITE
    sel.register(conn, events, data=data)

# ...
```

Маска событий, сокет и объекты данных затем передаются в sel.register().

Теперь взгляните на service_connection(), чтобы увидеть, как обрабатывается клиентское соединение, когда оно готово:

```cython
# multiconn-server.py

# ...

def service_connection(key, mask):
    sock = key.fileobj
    data = key.data
    if mask & selectors.EVENT_READ:
        recv_data = sock.recv(1024)  # Should be ready to read
        if recv_data:
            data.outb += recv_data
        else:
            print(f"Closing connection to {data.addr}")
            sel.unregister(sock)
            sock.close()
    if mask & selectors.EVENT_WRITE:
        if data.outb:
            print(f"Echoing {data.outb!r} to {data.addr}")
            sent = sock.send(data.outb)  # Should be ready to write
            data.outb = data.outb[sent:]

# ...
```

Это сердце простого сервера с несколькими подключениями. key — это namedtuple, возвращенный из .select(), который содержит объект сокета (fileobj) и объект данных. mask содержит готовые события.

Если сокет готов к чтению, тогда mask & selectors.EVENT_READ оценивается как True, поэтому вызывается sock.recv(). Любые прочитанные данные добавляются в data.outb, чтобы их можно было отправить позже.

Обратите внимание на блок else:, чтобы проверить, не получены ли данные:

```cython
# multiconn-server.py

# ...

def service_connection(key, mask):
    sock = key.fileobj
    data = key.data
    if mask & selectors.EVENT_READ:
        recv_data = sock.recv(1024)  # Should be ready to read
        if recv_data:
            data.outb += recv_data
        else:
            print(f"Closing connection to {data.addr}")
            sel.unregister(sock)
            sock.close()
    if mask & selectors.EVENT_WRITE:
        if data.outb:
            print(f"Echoing {data.outb!r} to {data.addr}")
            sent = sock.send(data.outb)  # Should be ready to write
            data.outb = data.outb[sent:]

# ...
```

Если данные не получены, это означает, что клиент закрыл свой сокет, поэтому сервер тоже должен это сделать. Но не забудьте вызвать sel.unregister() перед закрытием, чтобы он больше не отслеживался .select().

Когда сокет готов к записи, что всегда должно иметь место для исправного сокета, любые полученные данные, хранящиеся в data.outb, передаются клиенту с помощью sock.send(). Отправленные байты затем удаляются из буфера отправки:

```cython
# multiconn-server.py

# ...

def service_connection(key, mask):

    # ...

    if mask & selectors.EVENT_WRITE:
        if data.outb:
            print(f"Echoing {data.outb!r} to {data.addr}")
            sent = sock.send(data.outb)  # Should be ready to write
            data.outb = data.outb[sent:]

# ...
```

Метод .send() возвращает количество отправленных байтов. Затем это число можно использовать с нотацией слайса в буфере .outb, чтобы отбросить отправленные байты.

# Multi-Connection Client

Теперь взгляните на клиент с несколькими подключениями, multiconn-client.py. Он очень похож на сервер, но вместо прослушивания соединений он начинает с инициации соединений через start_connections():
```cython
# multiconn-client.py

import sys
import socket
import selectors
import types

sel = selectors.DefaultSelector()
messages = [b"Message 1 from client.", b"Message 2 from client."]

def start_connections(host, port, num_conns):
    server_addr = (host, port)
    for i in range(0, num_conns):
        connid = i + 1
        print(f"Starting connection {connid} to {server_addr}")
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setblocking(False)
        sock.connect_ex(server_addr)
        events = selectors.EVENT_READ | selectors.EVENT_WRITE
        data = types.SimpleNamespace(
            connid=connid,
            msg_total=sum(len(m) for m in messages),
            recv_total=0,
            messages=messages.copy(),
            outb=b"",
        )
        sel.register(sock, events, data=data)

# ...
```

num_conns считывается из командной строки и представляет собой количество подключений к серверу, которые необходимо создать. Как и сервер, каждый сокет установлен в неблокирующий режим.

Вы используете .connect_ex() вместо .connect(), потому что .connect() сразу вызовет исключение BlockingIOError. Метод .connect_ex() изначально возвращает индикатор ошибки errno.EINPROGRESS вместо того, чтобы вызывать исключение, которое может помешать установлению соединения. Как только соединение установлено, сокет готов к чтению и записи и возвращается функцией .select().

После настройки сокета данные, которые вы хотите хранить в сокете, создаются с использованием SimpleNamespace. Сообщения, которые клиент будет отправлять на сервер, копируются с помощью messages.copy(), потому что каждое соединение будет вызывать socket.send() и изменять список. Все, что необходимо для отслеживания того, что клиент должен отправить, что он отправил и получил, включая общее количество байтов в сообщениях, хранится в данных объекта.

Проверьте изменения, сделанные из service_connection() сервера для версии клиента:

```diff
def service_connection(key, mask):
     sock = key.fileobj
     data = key.data
     if mask & selectors.EVENT_READ:
         recv_data = sock.recv(1024)  # Should be ready to read
         if recv_data:
-            data.outb += recv_data
+            print(f"Received {recv_data!r} from connection {data.connid}")
+            data.recv_total += len(recv_data)
-        else:
-            print(f"Closing connection {data.connid}")
+        if not recv_data or data.recv_total == data.msg_total:
+            print(f"Closing connection {data.connid}")
             sel.unregister(sock)
             sock.close()
     if mask & selectors.EVENT_WRITE:
+        if not data.outb and data.messages:
+            data.outb = data.messages.pop(0)
         if data.outb:
-            print(f"Echoing {data.outb!r} to {data.addr}")
+            print(f"Sending {data.outb!r} to connection {data.connid}")
             sent = sock.send(data.outb)  # Should be ready to write
             data.outb = data.outb[sent:]
```

Это в основном то же самое, но с одним важным отличием. Клиент отслеживает количество байтов, полученных от сервера, чтобы закрыть соединение со своей стороны. Когда сервер обнаруживает это, он также закрывает свою сторону соединения.

Обратите внимание, что при этом сервер зависит от поведения клиента: сервер ожидает, что клиент закроет свою сторону соединения, когда он закончит отправку сообщений. Если клиент не закрывается, сервер оставит соединение открытым. В реальном приложении вы можете захотеть защититься от этого на своем сервере, внедрив тайм-аут, чтобы предотвратить накопление клиентских подключений, если они не отправят запрос через определенное время.

# Running the Multi-Connection Client and Server

Теперь пришло время запустить multiconn-server.py и multiconn-client.py. Оба они используют аргументы командной строки. Вы можете запустить их без аргументов, чтобы увидеть параметры.

Для сервера передайте номера хоста и порта:

```pycon
$ python multiconn-server.py
Usage: multiconn-server.py <host> <port>
```
Для клиента также передайте количество подключений к серверу, num_connections:

```pycon
$ python multiconn-client.py
Usage: multiconn-client.py <host> <port> <num_connections>
```
Ниже приведен вывод сервера при прослушивании петлевого интерфейса на порту 65432:

```pycon
$ python multiconn-server.py 127.0.0.1 65432
Listening on ('127.0.0.1', 65432)
Accepted connection from ('127.0.0.1', 61354)
Accepted connection from ('127.0.0.1', 61355)
Echoing b'Message 1 from client.Message 2 from client.' to ('127.0.0.1', 61354)
Echoing b'Message 1 from client.Message 2 from client.' to ('127.0.0.1', 61355)
Closing connection to ('127.0.0.1', 61354)
Closing connection to ('127.0.0.1', 61355)
```
Ниже приведен вывод клиента, когда он создает два подключения к указанному выше серверу:

```pycon
$ python multiconn-client.py 127.0.0.1 65432 2
Starting connection 1 to ('127.0.0.1', 65432)
Starting connection 2 to ('127.0.0.1', 65432)
Sending b'Message 1 from client.' to connection 1
Sending b'Message 2 from client.' to connection 1
Sending b'Message 1 from client.' to connection 2
Sending b'Message 2 from client.' to connection 2
Received b'Message 1 from client.Message 2 from client.' from connection 1
Closing connection 1
Received b'Message 1 from client.Message 2 from client.' from connection 2
Closing connection 2
```
Отлично! Теперь вы запустили клиент и сервер с несколькими подключениями. В следующем разделе вы еще больше разовьете этот пример.

### Application Client and Server

Пример клиента и сервера с множественными подключениями определенно является улучшением по сравнению с тем, с чего вы начали. Однако теперь вы можете сделать еще один шаг и устранить недостатки предыдущего примера multiconn в окончательной реализации: приложение-клиент и сервер.

Вам нужны клиент и сервер, которые должным образом обрабатывают ошибки, чтобы не затрагивать другие соединения. Очевидно, что ваш клиент или сервер не должны рухнуть в ярости, если исключение не перехвачено. Это то, о чем вам не приходилось беспокоиться до сих пор, потому что в примерах намеренно опущена обработка ошибок для краткости и ясности.

Теперь, когда вы знакомы с базовым API, неблокирующими сокетами и .select(), вы можете добавить некоторую обработку ошибок и обратиться к слону в комнате, которого примеры спрятали от вас за этой большой занавеской . Помните тот пользовательский класс, который упоминался во введении? Это то, что вы собираетесь исследовать дальше.

Сначала вы устраните ошибки:

«Все ошибки порождают исключения. Могут быть вызваны обычные исключения для недопустимых типов аргументов и условий нехватки памяти; начиная с Python 3.3, ошибки, связанные с семантикой сокетов или адресов, вызывают OSError или один из его подклассов». (Источник)

Итак, одна вещь, которую вам нужно сделать, это поймать OSError. Еще одним важным соображением в отношении ошибок являются тайм-ауты. Вы увидите их обсуждение во многих местах документации. Тайм-ауты случаются и являются так называемой нормальной ошибкой. Хосты и маршрутизаторы перезагружаются, порты коммутатора выходят из строя, кабели выходят из строя, кабели отключаются, что угодно. Вы должны быть готовы к этим и другим ошибкам, обрабатывая их в своем коде.

А как насчет слона в комнате? Как намекает тип сокета socket.SOCK_STREAM, при использовании TCP вы читаете из непрерывного потока байтов. Это похоже на чтение из файла на диске, но вместо этого вы читаете байты из сети. Однако, в отличие от чтения файла, f.seek() отсутствует.

Другими словами, вы не можете изменить положение указателя сокета, если он был, и перемещать данные.

Когда байты поступают в ваш сокет, задействованы сетевые буферы. После того, как вы их прочитали, их нужно где-то сохранить, иначе вы их потеряете. Вызов .recv() снова считывает следующий поток байтов, доступных из сокета.

Вы будете читать из сокета кусками. Итак, вам нужно вызвать .recv() и сохранить данные в буфере, пока вы не прочитаете достаточно байтов, чтобы получить полное сообщение, имеющее смысл для вашего приложения.

Вам решать определять и отслеживать границы сообщения. Что касается сокета TCP, он просто отправляет и получает необработанные байты в сеть и из сети. Он ничего не знает о том, что означают эти необработанные байты.

Вот почему вам необходимо определить протокол прикладного уровня. Что такое протокол прикладного уровня? Проще говоря, ваше приложение будет отправлять и получать сообщения. Формат этих сообщений соответствует протоколу вашего приложения.

Другими словами, длина и формат, которые вы выбираете для этих сообщений, определяют семантику и поведение вашего приложения. Это напрямую связано с тем, что вы узнали в предыдущем абзаце относительно чтения байтов из сокета. Когда вы читаете байты с помощью .recv(), вам нужно следить за тем, сколько байтов было прочитано, и выяснять, где проходят границы сообщения.

Как вы можете это сделать? Один из способов — всегда отправлять сообщения фиксированной длины. Если они всегда одного размера, то это легко. Когда вы прочитали это количество байтов в буфер, вы знаете, что у вас есть одно полное сообщение.

Однако использование сообщений фиксированной длины неэффективно для небольших сообщений, где вам нужно использовать отступы для их заполнения. Кроме того, у вас все еще остается проблема, что делать с данными, которые не помещаются в одно сообщение.

В этом руководстве вы познакомитесь с общим подходом, который используется во многих протоколах, включая HTTP. Вы будете префиксировать сообщения с заголовком, который включает длину содержимого, а также любые другие поля, которые вам нужны. Делая это, вам нужно будет только идти в ногу с заголовком. Прочитав заголовок, вы можете обработать его, чтобы определить длину содержимого сообщения. С длиной содержимого вы можете прочитать это количество байтов, чтобы использовать его.

Вы реализуете это, создав собственный класс, который может отправлять и получать сообщения, содержащие текст или двоичные данные. Вы можете улучшить и расширить этот класс для своих собственных приложений. Самое главное, что вы сможете увидеть пример того, как это делается.

Прежде чем вы начнете, вам нужно кое-что знать о сокетах и ​​байтах. Как вы узнали ранее, при отправке и получении данных через сокеты вы отправляете и получаете необработанные байты.

Если вы получаете данные и хотите использовать их в контексте, где они интерпретируются как несколько байтов, например 4-байтовое целое число, вам необходимо учитывать, что они могут быть в формате, который не является родным для ЦП вашей машины. Клиент или сервер на другом конце могут иметь

```pycon
$ python -c 'import sys; print(repr(sys.byteorder))'
'little'
```
Если вы запустите это на виртуальной машине, которая эмулирует ЦП с обратным порядком байтов (PowerPC), то произойдет что-то вроде этого:

```pycon
$ python -c 'import sys; print(repr(sys.byteorder))'
'big'
```

В этом примере приложения ваш протокол прикладного уровня определяет заголовок как текст Unicode с кодировкой UTF-8. Для фактического содержания в сообщении, полезной нагрузки сообщения, вам все равно придется менять порядок байтов вручную, если это необходимо.

Это будет зависеть от вашего приложения и от того, нужно ли ему обрабатывать многобайтовые двоичные данные с машины с другим порядком байтов. Вы можете помочь своему клиенту или серверу внедрить поддержку двоичных файлов, добавив дополнительные заголовки и используя их для передачи параметров, подобно HTTP.

Не волнуйтесь, если это еще не имеет смысла. В следующем разделе вы увидите, как все это работает и сочетается друг с другом.

# Application Protocol Header
Теперь вы полностью определите заголовок протокола. Заголовок протокола:

Текст переменной длины
Юникод с кодировкой UTF-8
Словарь Python, сериализованный с использованием JSON
Обязательные заголовки или подзаголовки в словаре заголовков протокола следующие:

|Название         |Описание
|:---------------:|:------------------------------------------------------------------------------------------------------:|
|byteorder        |Порядок байтов машины (используется sys.byteorder). Это может не требоваться для вашего приложения.|
|content-length   |Длина содержимого в байтах.|
|content-type     |Тип содержимого полезной нагрузки, например text/json или binary/my-binary-type.|
|content-encoding |Кодировка, используемая содержимым, например, utf-8 для текста Unicode или двоичная для двоичных данных.|

Эти заголовки информируют получателя о содержимом полезной нагрузки сообщения. Это позволяет отправлять произвольные данные, предоставляя при этом достаточно информации, чтобы получатель мог правильно декодировать и интерпретировать контент. Поскольку заголовки находятся в словаре, можно легко добавить дополнительные заголовки, вставив пары ключ-значение по мере необходимости.

# Sending an Application Message

Есть еще небольшая проблема. У вас есть заголовок переменной длины, который удобен и гибок, но как узнать длину заголовка при его чтении с помощью .recv()?

Когда вы ранее узнали об использовании .recv() и границ сообщения, вы также узнали, что заголовки фиксированной длины могут быть неэффективными. Это правда, но вы собираетесь использовать небольшой 2-байтовый заголовок фиксированной длины в качестве префикса заголовка JSON, содержащего его длину.

Вы можете думать об этом как о гибридном подходе к отправке сообщений. По сути, вы запускаете процесс получения сообщения, отправляя сначала длину заголовка. Это облегчает получателю деконструкцию сообщения.

Чтобы лучше понять формат сообщения, просмотрите сообщение целиком:

![image](socket_img/socket_4.png)

Сообщение начинается с заголовка фиксированной длины из двух байтов, который является целым числом в сетевом порядке байтов. Это длина следующего заголовка, заголовка JSON переменной длины. Как только вы прочитали два байта с помощью .recv(), вы знаете, что можете обработать два байта как целое число, а затем прочитать это количество байтов перед декодированием заголовка JSON UTF-8.

Заголовок JSON содержит словарь дополнительных заголовков. Одним из них является длина содержимого, которая представляет собой количество байтов содержимого сообщения (не включая заголовок JSON). Как только вы вызвали .recv() и прочитали байты длины содержимого, вы достигли границы сообщения, то есть прочитали все сообщение.

# Application Message Class
Наконец-то расплата! В этом разделе вы изучите класс Message и увидите, как он используется с .select(), когда в сокете происходят события чтения и записи.

В этом примере приложения показано, какие типы сообщений могут разумно использоваться клиентом и сервером. На данный момент вы далеко за пределами игрушечных эхо-клиентов и серверов!

Для простоты и демонстрации того, как все будет работать в реальном приложении, в этом примере используется протокол приложения, реализующий базовую функцию поиска. Клиент отправляет запрос на поиск, а сервер ищет совпадение. Если запрос, отправленный клиентом, не распознается как поиск, сервер предполагает, что это двоичный запрос, и возвращает двоичный ответ.

Прочитав следующие разделы, запустив примеры и поэкспериментировав с кодом, вы увидите, как все работает. Затем вы можете использовать класс Message в качестве отправной точки и изменить его для собственного использования.

Приложение не так уж далеко от примера клиента и сервера multiconn. Код цикла событий остается прежним в app-client.py и app-server.py. Что вы собираетесь сделать, так это переместить код сообщения в класс с именем Message и добавить методы для поддержки чтения, записи и обработки заголовков и содержимого. Это отличный пример использования класса.

Как вы узнали раньше и увидите ниже, работа с сокетами подразумевает сохранение состояния. Используя класс, вы сохраняете все состояние, данные и код, объединенные в организованную единицу. Экземпляр класса создается для каждого сокета на клиенте и сервере при запуске или принятии соединения.

Класс в основном одинаков как для клиента, так и для сервера для методов-оболочек и служебных программ. Они начинаются со знака подчеркивания, например Message._json_encode(). Эти методы упрощают работу с классом. Они помогают другим методам, позволяя им оставаться короче и поддерживая принцип DRY.

Серверный класс Message работает по существу так же, как и клиентский, и наоборот. Разница в том, что клиент инициирует соединение и отправляет сообщение запроса, после чего обрабатывается ответное сообщение сервера. И наоборот, сервер ожидает соединения, обрабатывает сообщение запроса клиента, а затем отправляет ответное сообщение.

Это выглядит так:

|Step	|Endpoint	|Action/Message Content|
|:---:|:-------:|:-------------------------------------------------:|
|1	  |Client	  |Отправляет сообщение, содержащее содержимое запроса|
|2	  |Server	  |Получает и обрабатывает запрос клиента Сообщение|
|3	  |Server	  |Отправляет сообщение, содержащее содержимое ответа|
|4	  |Client	  |Получает и обрабатывает сообщение ответа сервера|

Вот макет файла и кода:

|Application	|File	          |Code
|:-----------:|:-------------:|:-----------------------:|
|Server	      |app-server.py	|Основной скрипт сервера|
|Server	      |libserver.py	  |Класс Message сервера|
|Client	      |app-client.py	|Основной сценарий клиента|
|Client	      |libclient.py	  |Клиентский класс Message|

# Message Entry Point
Понимание того, как работает класс Message, может оказаться непростой задачей, поскольку в его структуре есть аспект, который может быть неочевидным. Почему? Управление состоянием.

После создания объекта Message он связывается с сокетом, события которого отслеживаются с помощью selector.register():
```cython
# app-server.py

# ...

def accept_wrapper(sock):
    conn, addr = sock.accept()  # Should be ready to read
    print(f"Accepted connection from {addr}")
    conn.setblocking(False)
    message = libserver.Message(sel, conn, addr)
    sel.register(conn, selectors.EVENT_READ, data=message)

# ...
```
Когда события в сокете готовы, они возвращаются функцией selector.select(). Затем вы можете получить ссылку на объект сообщения, используя атрибут данных в ключевом объекте, и вызвать метод в сообщении:

```cython
# app-server.py

# ...

try:
    while True:
        events = sel.select(timeout=None)
        for key, mask in events:
            if key.data is None:
                accept_wrapper(key.fileobj)
            else:
                message = key.data
                try:
                    message.process_events(mask)
                # ...

# ...
```
Глядя на цикл обработки событий выше, вы увидите, что sel.select() находится на месте водителя. Это блокировка, ожидание событий в верхней части цикла. Он отвечает за пробуждение, когда события чтения и записи готовы к обработке в сокете. Это косвенно означает, что он также отвечает за вызов метода .process_events(). Вот почему .process_events() является точкой входа.

Вот что делает метод .process_events():
```cython
# libserver.py

# ...

class Message:
    def __init__(self, selector, sock, addr):
        # ...

    # ...

    def process_events(self, mask):
        if mask & selectors.EVENT_READ:
            self.read()
        if mask & selectors.EVENT_WRITE:
            self.write()

    # ...
```
Это хорошо: .process_events() прост. Он может делать только две вещи: вызывать .read() и .write().

Вот тут-то и начинается управление состоянием. Если бы другой метод зависел от переменных состояния, имеющих определенное значение, то они вызывались бы только из .read() и .write(). Это максимально упрощает логику, поскольку события поступают в сокет для обработки.

У вас может возникнуть соблазн использовать сочетание некоторых методов, которые проверяют текущие переменные состояния и, в зависимости от их значения, вызывают другие методы для обработки данных вне .read() или .write(). В конце концов, это, вероятно, окажется слишком сложным для управления и отслеживания.

Вам определенно следует изменить класс в соответствии с вашими потребностями, чтобы он работал лучше для вас, но вы, вероятно, получите наилучшие результаты, если сохраните проверки состояния и вызовы методов, которые зависят от этого состояния, в .read() и методы .write(), если это возможно.

Теперь посмотрите на .read(). Это версия сервера, но версия клиента такая же. Он просто использует другое имя метода, .process_response() вместо .process_request():
```cython
# libserver.py

# ...

class Message:

    # ...

    def read(self):
        self._read()

        if self._jsonheader_len is None:
            self.process_protoheader()

        if self._jsonheader_len is not None:
            if self.jsonheader is None:
                self.process_jsonheader()

        if self.jsonheader:
            if self.request is None:
                self.process_request()

    # ...
```

Сначала вызывается метод ._read(). Он вызывает socket.recv() для чтения данных из сокета и сохранения их в приемном буфере.

Помните, что при вызове socket.recv() все данные, составляющие полное сообщение, могут быть еще не получены. socket.recv(), возможно, потребуется снова вызвать. Вот почему существуют проверки состояния для каждой части сообщения перед вызовом соответствующего метода для его обработки.

Прежде чем метод обработает свою часть сообщения, он сначала проверяет, достаточно ли байтов было прочитано в приемный буфер. Если они есть, он обрабатывает соответствующие байты, удаляет их из буфера и записывает свои выходные данные в переменную, которая используется на следующем этапе обработки. Поскольку сообщение состоит из трех компонентов, существует три проверки состояния и вызовы методов обработки:

|Message Component	  |Method	                |Output
|:-------------------:|:---------------------:|:------------------:|
|Fixed-length header	|process_protoheader()  |self._jsonheader_len|
|JSON header	        |process_jsonheader()	  |self.jsonheader|
|Content	            |process_request()	    |self.request|

Затем проверьте .write(). Это версия сервера:
```cython
# libserver.py

# ...

class Message:

    # ...

    def write(self):
        if self.request:
            if not self.response_created:
                self.create_response()

        self._write()

    # ...
```

Метод .write() сначала проверяет наличие запроса. Если он существует, а ответ не был создан, вызывается .create_response(). Метод .create_response() устанавливает переменную состояния response_created и записывает ответ в буфер отправки.

Метод ._write() вызывает socket.send(), если в буфере отправки есть данные.

Помните, что при вызове socket.send() все данные в буфере отправки могут не стоять в очереди на передачу. Сетевые буферы для сокета могут быть заполнены, и может потребоваться повторный вызов socket.send(). Для этого существуют государственные проверки. Метод .create_response() следует вызывать только один раз, но ожидается, что ._write() нужно будет вызывать несколько раз.

Клиентская версия .write() аналогична:

```cython
# libclient.py

# ...

class Message:
    def __init__(self, selector, sock, addr, request):
        # ...

    def write(self):
        if not self._request_queued:
            self.queue_request()

        self._write()

        if self._request_queued:
            if not self._send_buffer:
                # Set selector to listen for read events, we're done writing.
                self._set_selector_events_mask("r")

    # ...
```

Поскольку клиент инициирует соединение с сервером и сначала отправляет запрос, проверяется переменная состояния _request_queued. Если запрос не поставлен в очередь, он вызывает .queue_request(). Метод queue_request() создает запрос и записывает его в буфер отправки. Он также устанавливает переменную состояния _request_queued, чтобы она вызывалась только один раз.

Как и для сервера, ._write() вызывает socket.send(), если в буфере отправки есть данные.

Заметным отличием клиентской версии .write() является последняя проверка того, поставлен ли запрос в очередь. Это будет объяснено подробнее в разделе Основной сценарий клиента, но причина этого в том, чтобы указать selector.select() прекратить мониторинг сокета для событий записи. Если запрос поставлен в очередь, а буфер отправки пуст, значит, вы закончили запись и вас интересуют только события чтения. Нет причин получать уведомления о том, что сокет доступен для записи.

В завершение этого раздела рассмотрим следующую мысль: основная цель этого раздела состояла в том, чтобы объяснить, что selector.select() вызывает класс Message через метод .process_events(), и описать, как осуществляется управление состоянием.

Это важно, потому что .process_events() будет вызываться много раз в течение жизни соединения. Поэтому убедитесь, что любые методы, которые следует вызывать только один раз, либо сами проверяют переменную состояния, либо переменная состояния, установленная методом, проверяется вызывающим.

# Server Main Script

В основном скрипте сервера app-server.py из командной строки считываются аргументы, указывающие интерфейс и порт для прослушивания:

```pycon
$ python app-server.py
Usage: app-server.py <host> <port>
```
Например, чтобы прослушивать петлевой интерфейс на порту 65432, введите:

```pycon
$ python app-server.py 127.0.0.1 65432
Listening on ('127.0.0.1', 65432)
```

Используйте пустую строку для <host> для прослушивания на всех интерфейсах.

После создания сокета выполняется вызов socket.setsockopt() с параметром socket.SO_REUSEADDR:

```cython
# app-server.py

# ...

host, port = sys.argv[1], int(sys.argv[2])
lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# Avoid bind() exception: OSError: [Errno 48] Address already in use
lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
lsock.bind((host, port))
lsock.listen()
print(f"Listening on {(host, port)}")
lsock.setblocking(False)
sel.register(lsock, selectors.EVENT_READ, data=None)

# ...
```

Установка этого параметра сокета позволяет избежать ошибки, когда адрес уже используется. Вы увидите это при запуске сервера на порту, который имеет соединения в состоянии TIME_WAIT.

Например, если сервер активно закрыл соединение, оно останется в состоянии TIME_WAIT в течение двух или более минут, в зависимости от операционной системы. Если вы попытаетесь снова запустить сервер до истечения срока действия состояния TIME_WAIT, вы получите исключение OSError для уже используемого адреса. Это гарантия того, что любые задержанные пакеты в сети не будут доставлены в неправильное приложение.

Цикл событий перехватывает любые ошибки, чтобы сервер мог оставаться в рабочем состоянии и продолжать работать:

```cython
# app-server.py

# ...

try:
    while True:
        events = sel.select(timeout=None)
        for key, mask in events:
            if key.data is None:
                accept_wrapper(key.fileobj)
            else:
                message = key.data
                try:
                    message.process_events(mask)
                except Exception:
                    print(
                        f"Main: Error: Exception for {message.addr}:\n"
                        f"{traceback.format_exc()}"
                    )
                    message.close()
except KeyboardInterrupt:
    print("Caught keyboard interrupt, exiting")
finally:
    sel.close()
```
Когда клиентское соединение принято, создается объект Message:
```cython
# app-server.py

# ...

def accept_wrapper(sock):
    conn, addr = sock.accept()  # Should be ready to read
    print(f"Accepted connection from {addr}")
    conn.setblocking(False)
    message = libserver.Message(sel, conn, addr)
    sel.register(conn, selectors.EVENT_READ, data=message)

# ...
```

Объект Message связан с сокетом в вызове sel.register() и изначально настроен на отслеживание только событий чтения. Как только запрос будет прочитан, вы измените его так, чтобы он прослушивал только события записи.

Преимущество использования этого подхода на сервере заключается в том, что в большинстве случаев, когда сокет исправен и нет проблем с сетью, он всегда будет доступен для записи.

Если вы указали sel.register() также отслеживать EVENT_WRITE, то цикл обработки событий немедленно проснется и уведомит вас об этом. Однако на данный момент нет причин просыпаться и вызывать .send() для сокета. Ответа на отправку нет, так как запрос еще не обработан. Это будет потреблять и тратить впустую ценные циклы ЦП.

# Server Message Class
В разделе «Точка входа сообщения» вы узнали, как вызывался объект Message, когда события сокета были готовы через .process_events(). Теперь вы узнаете, что происходит, когда данные считываются из сокета и компонент или часть сообщения готова к обработке сервером.

Методы появляются в классе в том порядке, в котором происходит обработка сообщения.

Когда сервер прочитает хотя бы два байта, заголовок фиксированной длины может быть обработан:

```cython
# libserver.py

# ...

class Message:
    def __init__(self, selector, sock, addr):
        # ...

    # ...

    def process_protoheader(self):
        hdrlen = 2
        if len(self._recv_buffer) >= hdrlen:
            self._jsonheader_len = struct.unpack(
                ">H", self._recv_buffer[:hdrlen]
            )[0]
            self._recv_buffer = self._recv_buffer[hdrlen:]

    # ...
```

Заголовок фиксированной длины представляет собой 2-байтовое целое число в сетевом или обратном порядке байтов. Он содержит длину заголовка JSON. Вы будете использовать struct.unpack() для чтения значения, его декодирования и сохранения в self._jsonheader_len. После обработки части сообщения, за которую он отвечает, .process_protoheader() удаляет его из приемного буфера.

Как и в случае с заголовком фиксированной длины, когда в приемном буфере достаточно данных, чтобы содержать заголовок JSON, его также можно обработать:

```cython
# libserver.py

# ...

class Message:

    # ...

    def process_jsonheader(self):
        hdrlen = self._jsonheader_len
        if len(self._recv_buffer) >= hdrlen:
            self.jsonheader = self._json_decode(
                self._recv_buffer[:hdrlen], "utf-8"
            )
            self._recv_buffer = self._recv_buffer[hdrlen:]
            for reqhdr in (
                "byteorder",
                "content-length",
                "content-type",
                "content-encoding",
            ):
                if reqhdr not in self.jsonheader:
                    raise ValueError(f"Missing required header '{reqhdr}'.")

    # ...
```

Метод self._json_decode() вызывается для декодирования и десериализации заголовка JSON в словарь. Поскольку заголовок JSON определен как Unicode с кодировкой UTF-8, utf-8 жестко закодирован в вызове. Результат сохраняется в self.jsonheader. После обработки фрагмента сообщения, за который он отвечает, process_jsonheader() удаляет его из приемного буфера.

Далее идет фактическое содержание или полезная нагрузка сообщения. Это описано в заголовке JSON в файле self.jsonheader. Когда байты длины содержимого доступны в приемном буфере, запрос может быть обработан:

```cython
# libserver.py

# ...

class Message:

    # ...

    def process_request(self):
        content_len = self.jsonheader["content-length"]
        if not len(self._recv_buffer) >= content_len:
            return
        data = self._recv_buffer[:content_len]
        self._recv_buffer = self._recv_buffer[content_len:]
        if self.jsonheader["content-type"] == "text/json":
            encoding = self.jsonheader["content-encoding"]
            self.request = self._json_decode(data, encoding)
            print(f"Received request {self.request!r} from {self.addr}")
        else:
            # Binary or unknown content-type
            self.request = data
            print(
                f"Received {self.jsonheader['content-type']} "
                f"request from {self.addr}"
            )
        # Set selector to listen for write events, we're done reading.
        self._set_selector_events_mask("w")

    # ...
```

После сохранения содержимого сообщения в переменной данных .process_request() удаляет его из приемного буфера. Затем, если тип содержимого — JSON, .process_request() декодирует и десериализует его. Если это не так, это примерное приложение предполагает, что это двоичный запрос, и просто печатает тип содержимого.

Последнее, что делает .process_request(), — это модифицирует селектор так, чтобы он отслеживал только события записи. В основном скрипте сервера, app-server.py, сокет изначально настроен на отслеживание только событий чтения. Теперь, когда запрос полностью обработан, вам больше не интересно читать.

Теперь можно создать ответ и записать его в сокет. Когда сокет доступен для записи, .create_response() вызывается из .write():

```cython
# libserver.py

# ...

class Message:

    # ...

    def create_response(self):
        if self.jsonheader["content-type"] == "text/json":
            response = self._create_response_json_content()
        else:
            # Binary or unknown content-type
            response = self._create_response_binary_content()
        message = self._create_message(**response)
        self.response_created = True
        self._send_buffer += message
```

Ответ создается путем вызова других методов в зависимости от типа контента. В этом примере приложения простой поиск в словаре выполняется для запросов JSON, когда действие == 'поиск'. Для ваших собственных приложений вы можете определить другие методы, которые вызываются здесь.

После создания ответного сообщения переменная состояния self.response_created устанавливается таким образом, что .write() больше не вызывает .create_response(). Наконец, ответ добавляется в буфер отправки. Это видно и отправляется через ._write().

Один сложный момент заключается в том, как закрыть соединение после того, как ответ написан. Вы можете поместить вызов .close() в метод ._write():

```cython
# libserver.py

# ...

class Message:

    # ...

    def _write(self):
        if self._send_buffer:
            print(f"Sending {self._send_buffer!r} to {self.addr}")
            try:
                # Should be ready to write
                sent = self.sock.send(self._send_buffer)
            except BlockingIOError:
                # Resource temporarily unavailable (errno EWOULDBLOCK)
                pass
            else:
                self._send_buffer = self._send_buffer[sent:]
                # Close when the buffer is drained. The response has been sent.
                if sent and not self._send_buffer:
                    self.close()

    # ...
```

Хотя это несколько скрыто, это приемлемый компромисс, учитывая, что класс Message обрабатывает только одно сообщение для каждого соединения. После того, как ответ написан, серверу больше нечего делать. Он завершил свою работу.

# Client Main Script

В основном скрипте клиента app-client.py аргументы считываются из командной строки и используются для создания запросов и запуска подключений к серверу:

```pycon
$ python app-client.py
Usage: app-client.py <host> <port> <action> <value>
```
Вот пример:

```pycon
$ python app-client.py 127.0.0.1 65432 search needle
```
После создания словаря, представляющего запрос из аргументов командной строки, хост, порт и словарь запросов передаются в .start_connection():
```cython
# app-client.py

# ...

def start_connection(host, port, request):
    addr = (host, port)
    print(f"Starting connection to {addr}")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setblocking(False)
    sock.connect_ex(addr)
    events = selectors.EVENT_READ | selectors.EVENT_WRITE
    message = libclient.Message(sel, sock, addr, request)
    sel.register(sock, events, data=message)

# ...
```
Сокет создается для подключения к серверу, а также объект Message с использованием словаря запросов.

Как и для сервера, объект Message связан с сокетом в вызове sel.register(). Однако для клиента сокет изначально настроен на отслеживание как событий чтения, так и записи. Как только запрос будет написан, вы измените его, чтобы прослушивать только события чтения.

Этот подход дает вам то же преимущество, что и сервер: не тратить циклы ЦП впустую. После того, как запрос был отправлен, вас больше не интересуют события записи, поэтому нет причин просыпаться и обрабатывать их.

Класс клиентского сообщения
В разделе «Точка входа сообщения» вы узнали, как объект сообщения вызывался к действию, когда события сокета были готовы через .process_events(). Теперь вы узнаете, что происходит после того, как данные будут прочитаны и записаны в сокет, и сообщение будет готово для обработки клиентом.

Методы появляются в классе в том порядке, в котором происходит обработка сообщения.

Первая задача клиента — поставить запрос в очередь:
```cython
# libclient.py

# ...

class Message:

    # ...

    def queue_request(self):
        content = self.request["content"]
        content_type = self.request["type"]
        content_encoding = self.request["encoding"]
        if content_type == "text/json":
            req = {
                "content_bytes": self._json_encode(content, content_encoding),
                "content_type": content_type,
                "content_encoding": content_encoding,
            }
        else:
            req = {
                "content_bytes": content,
                "content_type": content_type,
                "content_encoding": content_encoding,
            }
        message = self._create_message(**req)
        self._send_buffer += message
        self._request_queued = True

    # ...
```
Словари, используемые для создания запроса, в зависимости от того, что было передано в командной строке, находятся в основном сценарии клиента, app-client.py. Словарь запроса передается в качестве аргумента классу при создании объекта Message.

Сообщение запроса создается и добавляется в буфер отправки, который затем просматривается и отправляется через ._write(). Переменная состояния self._request_queued установлена ​​таким образом, что .queue_request() больше не вызывается.

После отправки запроса клиент ожидает ответа от сервера.

Методы чтения и обработки сообщения на клиенте такие же, как и на сервере. Когда данные ответа считываются из сокета, вызываются методы заголовка процесса: .process_protoheader() и .process_jsonheader().

Разница заключается в названии конечных методов процесса и в том, что они обрабатывают ответ, а не создают его: .process_response(), ._process_response_json_content() и ._process_response_binary_content().

Последнее, но не менее важное, это последний вызов .process_response():

```cython
# libclient.py

# ...

class Message:

    # ...

    def process_response(self):

        # ...

        # Close when response has been processed
        self.close()

    # ...
```

# Message Class Wrapup
Чтобы завершить знакомство с классом Message, стоит упомянуть пару вещей, на которые важно обратить внимание применительно к некоторым вспомогательным методам.

Любые исключения, вызванные классом, перехватываются основным сценарием в предложении кроме исключения внутри цикла обработки событий:

```cython
# app-client.py

# ...

try:
    while True:
        events = sel.select(timeout=1)
        for key, mask in events:
            message = key.data
            try:
                message.process_events(mask)
            except Exception:
                print(
                    f"Main: Error: Exception for {message.addr}:\n"
                    f"{traceback.format_exc()}"
                )
                message.close()
        # Check for a socket being monitored to continue.
        if not sel.get_map():
            break
except KeyboardInterrupt:
    print("Caught keyboard interrupt, exiting")
finally:
    sel.close()
```

Обратите внимание на строку: message.close().

Это действительно важная линия по нескольким причинам! Он не только гарантирует, что сокет закрыт, но message.close() также удаляет сокет из-под контроля .select(). Это значительно упрощает код в классе и снижает сложность. Если есть исключение или вы сами его явно вызвали, вы знаете, что .close() позаботится об очистке.

Методы Message._read() и Message._write() тоже содержат кое-что интересное:

```cython
# libclient.py

# ...

class Message:

    # ...

    def _read(self):
        try:
            # Should be ready to read
            data = self.sock.recv(4096)
        except BlockingIOError:
            # Resource temporarily unavailable (errno EWOULDBLOCK)
            pass
        else:
            if data:
                self._recv_buffer += data
            else:
                raise RuntimeError("Peer closed.")

    # ...
```

Обратите внимание на строку exclude BlockingIOError:.

У метода ._write() он тоже есть. Эти строки важны, потому что они перехватывают временную ошибку и пропускают ее с помощью pass. Временная ошибка возникает, когда сокет блокируется, например, если он ожидает в сети или на другом конце соединения, также известном как его одноранговый узел.

Перехватив и пропустив исключение с помощью pass, .select() в конечном итоге вызовет новый вызов, и вы получите еще один шанс прочитать или записать данные.

### Running the Application Client and Server
После всей этой тяжелой работы пришло время повеселиться и поискать!

В этих примерах вы запустите сервер так, чтобы он прослушивал все интерфейсы, передав пустую строку в качестве аргумента хоста. Это позволит вам запустить клиент и подключиться с виртуальной машины, которая находится в другой сети. Он эмулирует машину PowerPC с обратным порядком байтов.

Сначала запустите сервер:
```pycon
$ python app-server.py '' 65432
Listening on ('', 65432)
```
Теперь запустите клиент и введите поиск. Посмотрим, сможешь ли ты его найти:

```pycon
$ python app-client.py 10.0.1.1 65432 search morpheus
Starting connection to ('10.0.1.1', 65432)
Sending b'\x00d{"byteorder": "big", "content-type": "text/json", "content-encoding": "utf-8", "content-length": 41}{"action": "search", "value": "morpheus"}' to ('10.0.1.1', 65432)
Received response {'result': 'Follow the white rabbit. 🐰'} from ('10.0.1.1', 65432)
Got result: Follow the white rabbit. 🐰
Closing connection to ('10.0.1.1', 65432)
```

Вы могли заметить, что в терминале работает оболочка, использующая текстовую кодировку Unicode (UTF-8), поэтому приведенный выше вывод хорошо печатается с эмодзи.

Теперь посмотрим, сможете ли вы найти щенков:

```pycon
$ python app-client.py 10.0.1.1 65432 search 🐶
Starting connection to ('10.0.1.1', 65432)
Sending b'\x00d{"byteorder": "big", "content-type": "text/json", "content-encoding": "utf-8", "content-length": 37}{"action": "search", "value": "\xf0\x9f\x90\xb6"}' to ('10.0.1.1', 65432)
Received response {'result': '🐾 Playing ball! 🏐'} from ('10.0.1.1', 65432)
Got result: 🐾 Playing ball! 🏐
Closing connection to ('10.0.1.1', 65432)
```
Обратите внимание на строку байтов, отправляемую по сети для запроса в строке отправки. Это легче увидеть, если вы посмотрите на байты, напечатанные в шестнадцатеричном формате, которые представляют эмодзи щенка: \xf0\x9f\x90\xb6. Если ваш терминал использует Unicode с кодировкой UTF-8, вы сможете ввести эмодзи для поиска.

Это демонстрирует, что вы отправляете необработанные байты по сети, и они должны быть декодированы получателем для правильной интерпретации. Вот почему вы приложили все усилия, чтобы создать заголовок, содержащий тип контента и кодировку.

Вот вывод сервера из обоих клиентских подключений выше:

```pycon
Accepted connection from ('10.0.2.2', 55340)
Received request {'action': 'search', 'value': 'morpheus'} from ('10.0.2.2', 55340)
Sending b'\x00g{"byteorder": "little", "content-type": "text/json", "content-encoding": "utf-8", "content-length": 43}{"result": "Follow the white rabbit. \xf0\x9f\x90\xb0"}' to ('10.0.2.2', 55340)
Closing connection to ('10.0.2.2', 55340)

Accepted connection from ('10.0.2.2', 55338)
Received request {'action': 'search', 'value': '🐶'} from ('10.0.2.2', 55338)
Sending b'\x00g{"byteorder": "little", "content-type": "text/json", "content-encoding": "utf-8", "content-length": 37}{"result": "\xf0\x9f\x90\xbe Playing ball! \xf0\x9f\x8f\x90"}' to ('10.0.2.2', 55338)
Closing connection to ('10.0.2.2', 55338)
```

Посмотрите на строку отправки, чтобы увидеть байты, которые были записаны в сокет клиента. Это ответное сообщение сервера.

Вы также можете протестировать отправку бинарных запросов на сервер, если аргумент действия отличается от поиска:

```pycon
$ python app-client.py 10.0.1.1 65432 binary 😃
Starting connection to ('10.0.1.1', 65432)
Sending b'\x00|{"byteorder": "big", "content-type": "binary/custom-client-binary-type", "content-encoding": "binary", "content-length": 10}binary\xf0\x9f\x98\x83' to ('10.0.1.1', 65432)
Received binary/custom-server-binary-type response from ('10.0.1.1', 65432)
Got response: b'First 10 bytes of request: binary\xf0\x9f\x98\x83'
Closing connection to ('10.0.1.1', 65432)
```

Поскольку тип контента запроса не text/json, сервер обрабатывает его как настраиваемый двоичный тип и не выполняет декодирование JSON. Он просто печатает тип содержимого и возвращает клиенту первые десять байтов:
```pycon
$ python app-server.py '' 65432
Listening on ('', 65432)
Accepted connection from ('10.0.2.2', 55320)
Received binary/custom-client-binary-type request from ('10.0.2.2', 55320)
Sending b'\x00\x7f{"byteorder": "little", "content-type": "binary/custom-server-binary-type", "content-encoding": "binary", "content-length": 37}First 10 bytes of request: binary\xf0\x9f\x98\x83' to ('10.0.2.2', 55320)
Closing connection to ('10.0.2.2', 55320)
```

### Troubleshooting

Неизбежно что-то не сработает, и вы будете задаваться вопросом, что делать. Не волнуйтесь, это случается со всеми. Надеемся, что с помощью этого руководства, вашего отладчика и вашей любимой поисковой системы вы сможете снова приступить к работе с исходным кодом.

Если нет, вашей первой остановкой должна быть документация модуля сокетов Python. Убедитесь, что вы прочитали всю документацию по каждой функции или методу, который вы вызываете. Кроме того, прочитайте раздел «Справочник» ниже, чтобы найти идеи. В частности, проверьте раздел «Ошибки».

Иногда дело не только в исходном коде. Исходный код может быть правильным, и это просто другой хост, клиент или сервер. Или это может быть сеть. Возможно, маршрутизатор, брандмауэр или другое сетевое устройство играет роль посредника.

Для таких типов проблем необходимы дополнительные инструменты. Ниже приведены несколько инструментов и утилит, которые могут помочь или, по крайней мере, дать некоторые подсказки.

# ping

ping проверит, жив ли хост и подключен ли он к сети, отправив эхо-запрос ICMP. Он напрямую взаимодействует со стеком протоколов TCP/IP операционной системы, поэтому он работает независимо от любого приложения, запущенного на хосте.

Ниже приведен пример запуска ping на macOS:

```pycon
$ ping -c 3 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.058 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.165 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.164 ms

--- 127.0.0.1 ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 0.058/0.129/0.165/0.050 ms
```

Обратите внимание на статистику в конце вывода. Это может быть полезно, когда вы пытаетесь обнаружить периодически возникающие проблемы с подключением. Например, есть ли потеря пакетов? Насколько велика задержка? Вы можете проверить время в оба конца.

Если между вами и другим хостом есть брандмауэр, эхо-запрос ping может быть запрещен. Некоторые администраторы брандмауэра реализуют политики, обеспечивающие это. Идея состоит в том, что они не хотят, чтобы их хосты можно было обнаружить. Если это так, и вы добавили правила брандмауэра, позволяющие узлам взаимодействовать, убедитесь, что правила также разрешают передачу ICMP между ними.

ICMP — это протокол, используемый ping, но это также протокол, который TCP и другие протоколы более низкого уровня используют для передачи сообщений об ошибках. Если вы испытываете странное поведение или медленное соединение, это может быть причиной.

Сообщения ICMP идентифицируются по типу и коду. Чтобы дать вам представление о важной информации, которую они несут, вот несколько из них:

|ICMP Type	|ICMP Code	|Description
|:---------:|:---------:|:-----------------------------------------:|
|8	        |0	        |Эхо-запрос|
|0	        |0	        |Эхо-ответ|
|3	        |0	        |Целевая сеть недоступна|
|3	        |1	        |Узел назначения недоступен|
|3	        |2	        |Протокол назначения недоступен|
|3	        |3	        |Порт назначения недоступен|
|3	        |4	        |Требуется фрагментация и установлен флаг DF|
|11	        |0	        |TTL истек в пути|

# netstat

В разделе «Просмотр состояния сокета» вы узнали, как можно использовать netstat для отображения информации о сокетах и ​​их текущем состоянии. Эта утилита доступна в macOS, Linux и Windows.

В этом разделе не упоминаются столбцы Recv-Q и Send-Q в выходных данных примера. Эти столбцы покажут вам количество байтов, хранящихся в сетевых буферах, которые стоят в очереди на передачу или получение, но по какой-то причине не были прочитаны или записаны удаленным или локальным приложением.

Другими словами, байты ожидают в сетевых буферах в очередях операционной системы. Одной из причин может быть то, что приложение привязано к ЦП или не может вызвать socket.recv() или socket.send() и обработать байты. Или могут быть сетевые проблемы, влияющие на связь, такие как перегрузка или неисправность сетевого оборудования или кабелей.

Чтобы продемонстрировать это и посмотреть, сколько данных вы можете отправить, прежде чем увидите ошибку, вы можете попробовать тестовый клиент, который подключается к тестовому серверу и неоднократно вызывает socket.send(). Тестовый сервер никогда не вызывает socket.recv(). Он просто принимает соединение. Это приводит к заполнению сетевых буферов на сервере, что в конечном итоге вызывает ошибку на клиенте.

Сначала запустите сервер:

```pycon
$ python app-server-test.py 127.0.0.1 65432
Listening on ('127.0.0.1', 65432)
```
Затем запустите клиент, чтобы увидеть, в чем ошибка:

```pycon
$ python app-client-test.py 127.0.0.1 65432 binary test
Error: socket.send() blocking io exception for ('127.0.0.1', 65432):
BlockingIOError(35, 'Resource temporarily unavailable')
```

Вот вывод netstat, когда клиент и сервер все еще работают, при этом клиент несколько раз распечатывает приведенное выше сообщение об ошибке:

```pycon
$ netstat -an | grep 65432
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4  408300      0  127.0.0.1.65432        127.0.0.1.53225        ESTABLISHED
tcp4       0 269868  127.0.0.1.53225        127.0.0.1.65432        ESTABLISHED
tcp4       0      0  127.0.0.1.65432        *.*                    LISTEN
```

Первая запись — это сервер (локальный адрес имеет порт 65432):

```pycon
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4  408300      0  127.0.0.1.65432        127.0.0.1.53225        ESTABLISHED
```

Обратите внимание на Recv-Q: 408300.

Вторая запись — это клиент (внешний адрес имеет порт 65432):

```pycon
Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
tcp4       0 269868  127.0.0.1.53225        127.0.0.1.65432        ESTABLISHED
```
Обратите внимание на Send-Q: 269868.

Клиент точно пытался записать байты, но сервер их не читал. Это привело к заполнению очереди сетевого буфера сервера на стороне приема и очереди сетевого буфера клиента на стороне отправки.

# Windows
Если вы работаете с Windows, есть набор утилит, которые вам обязательно стоит попробовать, если вы еще этого не сделали: Windows Sysinternals.

Одним из них является TCPView.exe. TCPView — это графический netstat для Windows. В дополнение к адресам, номерам портов и состоянию сокетов он покажет вам текущие итоги по количеству пакетов и байтов, отправленных и полученных. Как и в случае с утилитой Unix lsof, вы также получаете имя и идентификатор процесса. Проверьте меню для других параметров отображения.

![image](socket_img/socket_5.png)

# Wireshark
Иногда нужно посмотреть, что происходит на проводе. Забудьте о том, что говорит журнал приложения или какое значение возвращается из вызова библиотеки. Вы хотите видеть, что на самом деле отправляется или принимается в сети. Как и в случае с отладчиками, когда вам нужно это увидеть, ничто не заменит.

Wireshark — это анализатор сетевых протоколов и приложение для захвата трафика, которое работает, в частности, на macOS, Linux и Windows. Существует версия с графическим интерфейсом под названием wireshark, а также терминальная текстовая версия под названием tshark.

Запуск захвата трафика — отличный способ посмотреть, как приложение ведет себя в сети, и собрать данные о том, что оно отправляет и получает, как часто и в каком количестве. Вы также сможете увидеть, когда клиент или сервер закрывает или прерывает соединение или перестает отвечать на запросы. Эта информация может быть чрезвычайно полезна при устранении неполадок.

В Интернете есть много хороших руководств и других ресурсов, которые познакомят вас с основами использования Wireshark и TShark.

Вот пример перехвата трафика с помощью Wireshark на петлевом интерфейсе:

![image](socket_img/socket_6.png)
Вот тот же пример, показанный выше, с использованием tshark:

```pycon
$ tshark -i lo0 'tcp port 65432'
Capturing on 'Loopback'
    1   0.000000    127.0.0.1 → 127.0.0.1    TCP 68 53942 → 65432 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=32 TSval=940533635 TSecr=0 SACK_PERM=1
    2   0.000057    127.0.0.1 → 127.0.0.1    TCP 68 65432 → 53942 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=32 TSval=940533635 TSecr=940533635 SACK_PERM=1
    3   0.000068    127.0.0.1 → 127.0.0.1    TCP 56 53942 → 65432 [ACK] Seq=1 Ack=1 Win=408288 Len=0 TSval=940533635 TSecr=940533635
    4   0.000075    127.0.0.1 → 127.0.0.1    TCP 56 [TCP Window Update] 65432 → 53942 [ACK] Seq=1 Ack=1 Win=408288 Len=0 TSval=940533635 TSecr=940533635
    5   0.000216    127.0.0.1 → 127.0.0.1    TCP 202 53942 → 65432 [PSH, ACK] Seq=1 Ack=1 Win=408288 Len=146 TSval=940533635 TSecr=940533635
    6   0.000234    127.0.0.1 → 127.0.0.1    TCP 56 65432 → 53942 [ACK] Seq=1 Ack=147 Win=408128 Len=0 TSval=940533635 TSecr=940533635
    7   0.000627    127.0.0.1 → 127.0.0.1    TCP 204 65432 → 53942 [PSH, ACK] Seq=1 Ack=147 Win=408128 Len=148 TSval=940533635 TSecr=940533635
    8   0.000649    127.0.0.1 → 127.0.0.1    TCP 56 53942 → 65432 [ACK] Seq=147 Ack=149 Win=408128 Len=0 TSval=940533635 TSecr=940533635
    9   0.000668    127.0.0.1 → 127.0.0.1    TCP 56 65432 → 53942 [FIN, ACK] Seq=149 Ack=147 Win=408128 Len=0 TSval=940533635 TSecr=940533635
   10   0.000682    127.0.0.1 → 127.0.0.1    TCP 56 53942 → 65432 [ACK] Seq=147 Ack=150 Win=408128 Len=0 TSval=940533635 TSecr=940533635
   11   0.000687    127.0.0.1 → 127.0.0.1    TCP 56 [TCP Dup ACK 6#1] 65432 → 53942 [ACK] Seq=150 Ack=147 Win=408128 Len=0 TSval=940533635 TSecr=940533635
   12   0.000848    127.0.0.1 → 127.0.0.1    TCP 56 53942 → 65432 [FIN, ACK] Seq=147 Ack=150 Win=408128 Len=0 TSval=940533635 TSecr=940533635
   13   0.001004    127.0.0.1 → 127.0.0.1    TCP 56 65432 → 53942 [ACK] Seq=150 Ack=148 Win=408128 Len=0 TSval=940533635 TSecr=940533635
^C13 packets captured
```

### Conclusion

Вы охватили много вопросов в этом уроке! Сеть и сокеты - большие темы. Если вы новичок в сети или сокетах, не расстраивайтесь из-за всех терминов и аббревиатур.

Есть много частей, с которыми нужно ознакомиться, чтобы понять, как все работает вместе. Однако, как и в случае с Python, он станет более понятным, когда вы познакомитесь с отдельными частями и проведете с ними больше времени.

В этом уроке вы:

Изучил низкоуровневый API сокетов в модуле сокетов Python и увидел, как его можно использовать для создания клиент-серверных приложений.
Создан клиент и сервер, которые могут обрабатывать несколько подключений с помощью объекта селекторов.
Создал свой собственный класс и использовал его в качестве протокола прикладного уровня для обмена сообщениями и данными между конечными точками.
Отсюда вы можете использовать свой пользовательский класс и опираться на него, чтобы учиться и помогать создавать собственные приложения для сокетов проще и быстрее.
